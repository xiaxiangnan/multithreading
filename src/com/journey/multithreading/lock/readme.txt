ReentrantLock比较synchronized：
    首先他们肯定具有相同的功能和内存语义。
    1、与synchronized相比，ReentrantLock提供了更多，更加全面的功能，具备更强的扩展性。例如：时间锁等候，可中断锁等候，锁投票。
    2、ReentrantLock还提供了条件Condition，对线程的等待、唤醒操作更加详细和灵活，所以在多个条件变量和高度竞争锁的地方，ReentrantLock更加适合。
    3、ReentrantLock提供了可轮询的锁请求。它会尝试着去获取锁，如果成功则继续，否则可以等到下次运行时处理，而synchronized则一旦进入锁请求要么成功要么阻塞，所以相比synchronized而言，ReentrantLock会不容易产生死锁些。
    4、ReentrantLock支持更加灵活的同步代码块，但是使用synchronized时，只能在同一个synchronized块结构中获取和释放。注：ReentrantLock的锁释放一定要在finally中处理，否则可能会产生严重的后果。
    5、ReentrantLock支持中断处理，且性能较synchronized会好些。


共享锁和独占锁。
ReentrantLock就是独占锁。对于独占锁而言，它每次只能有一个线程持有，而共享锁则不同，它允许多个线程并行持有锁，并发访问共享资源。

自旋锁: 开启参数-XX:+UseSpinning,java6来说已经默认启用,自旋次数(-XX:PreBlockSpin=10)
使线程在没有获得锁的时候不被挂起,去执行一个空循环,若干空循环后,依然没获得锁就挂起.对于锁竞争不是很激烈,锁占用时间少的
并发线程,避免了线程频繁挂起和恢复对系统带来的压力

偏向锁: 开启-XX:+UseBiasedLocking,JDK6默认启用.
主要解决无竞争下的锁性能问题.按照之前的HotSpot设计，每次加锁/解锁都会涉及到一些CAS操作（比如对等待队列的CAS操作），
CAS操作会延迟本地调用，因此偏向锁的想法是一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个线程，
之后的多次调用则可以避免CAS操作，说白了就是置个变量，如果发现为true则无需再走各种加锁/解锁流程.
偏向锁引入的一个重要问题是，在多争用的场景下，如果另外一个线程争用偏向对象，拥有者需要释放偏向锁，
而释放的过程会带来一些性能开销，但总体说来偏向锁带来的好处还是大于CAS代价的。

悲观锁和乐观锁
1. 悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，
    这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，
    都是在做操作之前先上锁。
2. 乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，
    但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，
    这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。

同步辅助类: Phaser,CyclicBarrier,CountDownLatch,Exchanger
1. CyclicBarrier，允许一组线程互相等待，直到到达某个公共屏障点。它提供的await()可以实现让所有参与者在临界点到来之前一直处于等待状态。
2. CountDownLatch，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。它提供了await()、countDown()两个方法来进行操作。
3. Phaser，它把多个线程协作执行的任务划分为多个阶段，编程时需要明确各个阶段的任务，每个阶段都可以有任意个参与者，线程都可以随时注册并参与到某个阶段。
4. Exchanger,允许在两个线程之间定义同步点。当两个线程都到达同步点时，他们交换数据结构，因此第一个线程的数据结构进入到第二个线程中，第二个线程的数据结构进入到第一个线程中。


i++是一个非常经典的操作，它几乎充斥着我们每个人编写的代码中。i++是可以分解的，
    它分解为getI()、i + 1 、setI三个步骤，所以它并不是原子操作。

CAS原子操作:Compare and Swap, 翻译成比较并交换
java.util.concurrent包完全建立在CAS之上的,借助CAS实现了区别于synchronouse同步锁的一种乐观锁
CAS 操作包含三个操作数 - 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，
那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，
它都会在 CAS 指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值）
CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”

AQS:AbstractQueuedSynchronizer
AQS作为一个核心的处理框架，他提供了大量的同步操作，同时用户还可以在此类的基础上进行自定义，实现自己的同步器。
1、状态位state, AQS用的是一个32位的整型来表示同步状态的，它是用volatile修饰.
   在互斥锁中它表示着线程是否已经获取了锁，0未获取，1已经获取了，大于1表示重入数。
   同时AQS提供了getState()、setState()、compareAndSetState()方法来获取和修改该值
2、CLH同步队列, AQS内部维护着一个FIFO的变种CLH队列.
3、共享锁、互斥锁, 在AQS维护的CLH队列锁中，每个节点（Node）代表着一个需要获取锁的线程。
   该Node中有两个常量SHARE、EXCLUSIVE。其中SHARE代表着共享模式，EXCLUSIVE代表着独占模式。
   共享模式是允许多个线程可以获取同一个锁，而独占模式则一个锁只能被一个线程持有，其他线程必须要等待
4、阻塞、唤醒, Java内置锁时，可以使用wait、notify方法来阻塞、唤醒线程，但是AQS并没有采用该模式，
   而是通过LockSupport.park() 和 LockSupport.unpark() 的本地方法来实现线程的阻塞和唤醒。

AQS锁获取:
1、首先线程尝试获取锁，如果成功则直接返回，不成功则新建一个Node节点并添加到CLH队列中,进入2
2、判断是否为CLH队列中的非空头节点(head结点使用的是傀儡结点),若不是头节点,判断是否需要挂起来挂起当前节点,若
  是头节点通过CAS操作尝试获取锁返回.
AQS锁释放:
尝试释放锁,寻找继任节点,唤醒继任节点,成功返回true,失败返回false



参考: http://cmsblogs.com/?cat=97